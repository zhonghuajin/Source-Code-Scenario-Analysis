函数    线程号    行号    注释
io.netty.bootstrap.AbstractBootstrap.bind    1    242    //这个bind函数是一个很顶层的封装，背后涉及了AbstractBootstrap启动器准备一整条eventloop到NioServerSocketChannel的工作通道，并对整条工作通道涉及的节点进行初始化的工作。
io.netty.bootstrap.AbstractBootstrap.bind    1    263    //略
io.netty.bootstrap.ServerBootstrap.validate    1    193    //判断bind操作的前提条件是否已经准备好（准备好NioEventLoopGroup和NioServerSocketChannel）
io.netty.bootstrap.AbstractBootstrap.validate    1    200    //略
io.netty.util.internal.InternalThreadLocalMap.random    1    210        //获取全局随机数。java.util.Random存在多线程竞争，netty结合自己实现的ThreadLocal实现了自己的Random，每个线程获取Random都不会影响其他线程。
io.netty.util.internal.ThreadLocalRandom.setSeed    1    225    //略
io.netty.util.internal.ThreadLocalRandom.next    1    232    //略
io.netty.util.internal.ThreadLocalRandom.next    1    232    //略
io.netty.channel.nio.AbstractNioMessageChannel.newUnsafe    1    45    //这里new一个Nio的unsafe给通道，没有这个东西通道是读不了数据的。当前正在new NioServerSocketChannel，过程中会给这个通道一个unsafe。
io.netty.channel.DefaultChannelPipeline.channel    1    85    //返回pipeline的通道
io.netty.channel.nio.AbstractNioChannel.unsafe    1    108    //略
io.netty.channel.AbstractChannel.unsafe    1    279    //略
io.netty.channel.socket.nio.NioServerSocketChannel.javaChannel    1    115    //返回Nid层的ServerSocketChannel
io.netty.channel.nio.AbstractNioChannel.javaChannel    1    112    //略
io.netty.channel.socket.nio.NioServerSocketChannel.config    1    100       //获取channel的配置
io.netty.channel.DefaultChannelConfig.setOptions    1    107    //修改通道的配置。当前场景中其实什么都没配
io.netty.channel.AbstractChannel.pipeline    1    99    //返回通道的pipeline
io.netty.channel.DefaultChannelPipeline.addLast    1    244    //pipeline中加一个handler。bind的过程中有两个handler，一个是用于处于通道的初始化的ChannelInitializer（就是当前正在添加的handler），另一个是用来处理连接请求的ServerBootstrapAcceptor（下面会看到），主线程给bossgroup线程的添加ChannelInitializer,bossgroup线程收到主线程的注册事件后传播到ChannelInitializer,它会把ServerBootstrapAcceptor插入到NioServerSocketChannel的pipeline中，这个过程下面会看到的。
io.netty.channel.DefaultChannelPipeline.addLast    1    249    //略
io.netty.channel.DefaultChannelPipeline.addLast    1    125    //略
io.netty.channel.DefaultChannelHandlerContext.handler    1    35    //返回context的handler。添加一个handler总是伴随添加一个context，pipeline实际上是一个context链表，每个节点都有一个handler，这里就是通过新添加的context获取handler
io.netty.channel.ChannelHandlerAdapter.isSharable    1    45    //判断handler是否可以由多个channel共享
io.netty.util.internal.InternalThreadLocalMap.handlerSharableCache    1    242    //返回handlerSharableCache，这是一个map，保存了可以共享的handler的信息。每个线程都有自己的InternalThreadLocalMap实例，handlerSharableCache是它的重要成员之一
io.netty.channel.AbstractChannelHandlerContext.channel    1    97    //略
io.netty.channel.AbstractChannel.isRegistered    1    157     //判断channel是否已经注册完成。执行到这里handler已经加到pipeline中，如果判断channel已经注册，接下来会执行handler添加成功后的回调（由handler自己提供，自定义的handler可以实现这个函数）
io.netty.channel.DefaultChannelHandlerContext.handler    1    35    //略
io.netty.channel.ChannelHandlerAdapter.handlerAdded    1    61    //略。当前的ChannelInitializer是netty提供的，netty没给这个handler实现这个函数，所以是个空函数。
io.netty.bootstrap.AbstractBootstrap.group    1    384    //获取bossGroup
io.netty.channel.MultithreadEventLoopGroup.register    1    64    //把NioServerSocketChannel注册到bossgroup中。注册是作为一个异步请求由主线程像bossGroup发起的，bossGroup线程启动之后就会处理这个事件，下面会看到。
io.netty.channel.MultithreadEventLoopGroup.next    1    59    //略
io.netty.util.concurrent.MultithreadEventExecutorGroup.next    1    110    //略
io.netty.channel.SingleThreadEventLoop.register    1    48    //略
io.netty.channel.SingleThreadEventLoop.register    1    53    //略
io.netty.channel.nio.AbstractNioChannel.unsafe    1    108    //略
io.netty.channel.AbstractChannel.unsafe    1    279    //略
io.netty.channel.AbstractChannel.isRegistered    1    157    //判断通道是否已经注册。执行到这里之前其实还是在register的层层封装中，到这里主线程才准备向bossGroup线程发起注册请求，先判断一下通道是否已经注册，通道只能注册一次，否则会导致多个线程竞争通道的问题
io.netty.channel.nio.AbstractNioChannel.isCompatible    1    328    //判断当前的eventloop是不是真的是eventloop(不太理解什么情况下才会出现false的情况）
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    1    39    //判断当前正在运行的线程是不是eventloop绑定的线程，只有channel注册的线程才可以操作channel相关的数据结构。发起请求的线程有时候（比如注册）可以持有channel的句柄，所以有些操作必须做这个见检查，凡是检查通不过的，都会通过发送异步请求的方式执行当前的操作。
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    1    428    //略
io.netty.util.concurrent.SingleThreadEventExecutor.execute    1    682    //给eventloop的任务队列添加一个任务。当前场景中主线程通不过inEventLoop的检查，所以把注册任务送给了bossGroup处理，送任务之前会先启动bossGroup对应的线程。
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    1    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    1    428    //略
io.netty.util.internal.UnsafeAtomicIntegerFieldUpdater.compareAndSet    1    39    //更新eventloop当前的状态。执行到这里eventloop对应的线程已经通过execute函数启动了，要修改eventloop的状态
io.netty.util.concurrent.SingleThreadEventExecutor.updateLastExecutionTime    18    405    //记录最近一次execute的时间。执行到这里，bossGroup线程正式启动，由于线程的启动是在execute的过程中的，所以启动的时候就记录一次execute的时间，这个不是精准的时间。
io.netty.channel.nio.NioEventLoop.run    18    305    //bossGroup正式开始工作
io.netty.util.concurrent.SingleThreadEventExecutor.addTask    1    296    //添加一个任务到任务队列中。这里是往bossGroup的任务队列中加任务，这个任务是一个通道注册任务，让bossGroup线程自己处理自己通道的注册。
io.netty.util.concurrent.SingleThreadEventExecutor.isShutdown    1    602    //判断eventloop对应的线程是否已经退出，退出就不要加任务了
io.netty.util.internal.MpscLinkedQueue.add    1    218    //略
io.netty.util.internal.MpscLinkedQueue.offer    1    114    //略
io.netty.util.internal.MpscLinkedQueueTailRef.getAndSetTailRef    1    52    //略
io.netty.util.internal.UnsafeAtomicReferenceFieldUpdater.get    1    60    //略
io.netty.util.internal.UnsafeAtomicReferenceFieldUpdater.compareAndSet    1    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.isShutdown    1    602    //到这里任务已经添加完成，但是如果这个时候发现处理时间的线程已经退出了，就不能再让这个任务存在了，要删掉它
io.netty.channel.SingleThreadEventLoop.wakesUpForTask    1    66    //添加任务后判断要不要唤醒处于select阻塞状态的eventloop。NonWakeupRunnable类型的task添加到taskqueue之后是不需要唤醒的。
io.netty.channel.nio.NioEventLoop.wakeup    1    590    //给bossGroup加一个WAKEUP_TASK任务
io.netty.util.internal.MpscLinkedQueueHeadRef.lazySetHeadRef    18    52    //到这里，bossGroup开始工作了，从taskqueue中poll任务出来处理。涉及MpscLinkedQueue的poll操作，太底层的这里都不讨论，不会影响理解netty整体设计思想
io.netty.util.internal.MpscLinkedQueueNode.clearMaybe    18    56    //略
io.netty.util.internal.OneTimeTask.value    18    30        //略。注册时一个OneTimeTask任务，value就是这个task本身。
io.netty.util.concurrent.DefaultPromise.setUncancellable    18    456    //设置异步操作禁止取消。注册请求不允许取消，注册都取消了其他任何操作都没有意义。
io.netty.channel.nio.AbstractNioChannel.isOpen    18    103    //判断通道是否还处于打开状态。通道都关了的话，注册是没意义的。
io.netty.channel.nio.AbstractNioChannel.doRegister    18    333        //通道注册到eveltloop的selector，同时生成代表通道感兴趣的事件的selectionKey
io.netty.channel.socket.nio.NioServerSocketChannel.javaChannel    18    115    //略
io.netty.channel.nio.AbstractNioChannel.javaChannel    18    112    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.DefaultPromise.cause    1    124    //读取异步操作失败的原因。主线程发送通道注册的请求给bossGroup后就返回了，返回之后可以通过每个异步请求都配套的future（promise）查看请求的结果，如果请求失败，future的cause里面会记录原因
io.netty.channel.DefaultChannelPromise.trySuccess    18    82    //设置promise的结果为success。表示通道注册这个异步请求已经成功处理了
io.netty.util.concurrent.DefaultPromise.trySuccess    18    405    //略
io.netty.util.concurrent.DefaultPromise.isDone    18    106    //判断promise是否已经done。done以为着promise的结果已经被设置过，这里就不可以再设置了
io.netty.util.concurrent.DefaultPromise.isDone    18    106    //略
io.netty.channel.DefaultChannelPipeline.fireChannelRegistered    18    733    //触发“已注册”事件在pipeline（context链）中传播。
io.netty.channel.AbstractChannelHandlerContext.fireChannelRegistered    18    126    //context节点传播“已注册”事件。fireXxxx中会调用下一个节点的invokeXxxx，比如当前context的fireChannelRegistered中会调用下一个context的invokeChannelRegistered，然后在里面调用下一个context的ChannelRegistered（这个函数可以什么都不做直接调用fireChannelRegistered继续传播）
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.DefaultChannelPromise.channel    1    66    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.DefaultChannelHandlerContext.handler    18    35    //略
io.netty.channel.ChannelInitializer.channelRegistered    18    68    //handler处理”已注册“事件。ChannelInitializer主要用来给channel添加handler，然后把自己从pipeline中删掉
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.AbstractChannel.pipeline    18    99    //略
io.netty.util.concurrent.DefaultPromise.cause    1    124    //略
io.netty.util.concurrent.DefaultPromise.isDone    1    106    //略
io.netty.channel.DefaultChannelPipeline.addLast    18    244    //添加handler到pipeline中。到这里为止新的通道只有ChannelInitializer一个handler，这个handler负责的就是把其他handler放到pipeline中，这里把ServerBootstrapAcceptor（负责accept新的连接）放到pipeline中。
io.netty.channel.DefaultChannelPipeline.addLast    18    249    //略
io.netty.channel.DefaultChannelPipeline.addLast    18    125    //略
io.netty.channel.DefaultChannelHandlerContext.handler    18    35    //略
io.netty.channel.ChannelHandlerAdapter.isSharable    18    45    //略
io.netty.util.concurrent.FastThreadLocalThread.threadLocalMap    18    62    //略
io.netty.util.concurrent.FastThreadLocalThread.setThreadLocalMap    18    70    //略
io.netty.util.internal.InternalThreadLocalMap.handlerSharableCache    18    242    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97        //略
io.netty.channel.AbstractChannel.isRegistered    18    157    //略
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.DefaultChannelHandlerContext.handler    18    35    //略
io.netty.channel.ChannelHandlerAdapter.handlerAdded    18    61    //略
io.netty.channel.AbstractChannelHandlerContext.pipeline    18    102    //略
io.netty.channel.DefaultChannelPipeline.remove    18    299    //执行到这里，ChannelInitializer最重要的任务addLast加handler到pipeline中已经完成，可以把它从pipeline中去掉了
io.netty.channel.DefaultChannelPipeline.context    18    632    //略
io.netty.channel.DefaultChannelHandlerContext.handler    18    35    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.AbstractChannel.isRegistered    18    157    //略
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.AbstractChannelHandlerContext.name    18    121    //删除handler最重要的是把handler对应的context删掉，context存在map中，通过context的name可以找到并删除
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.AbstractChannel.isRegistered    18    157    //略
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.DefaultChannelHandlerContext.handler    18    35    //略
io.netty.channel.ChannelHandlerAdapter.handlerRemoved    18    69    //handler被删掉之后的回调。ChannelInitializer没有实现这个函数，空的
io.netty.channel.AbstractChannelHandlerContext.fireChannelRegistered    18    126    //ChannelInitializer传播注册完成事件给下一个handler。下一个handler就是被ChannelInitializer新加到pipeline中的ServerBootstrapAcceptor
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.DefaultChannelHandlerContext.handler    18    35    //略
io.netty.channel.ChannelInboundHandlerAdapter.channelRegistered    18    42    //略
io.netty.channel.AbstractChannelHandlerContext.fireChannelRegistered    18    126    //略
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.socket.nio.NioServerSocketChannel.isActive    18    105    //判断通道是否是激活的。执行到这里，“已注册”事件已经在ServerSocketChannel中传播完了，如果通道是激活的，可以传播“激活”事件了，但是当前场景中是不激活的，因为真正的网络层的bind实际上还没开始，只有底层的socket成功绑定ip之后才算激活通道
io.netty.channel.socket.nio.NioServerSocketChannel.javaChannel    18    115    //略
io.netty.channel.nio.AbstractNioChannel.javaChannel    18    112    //略
io.netty.channel.DefaultChannelPromise.addListener    1    93    //给请求的promise加监听器。主线程发送了通道注册的事件之后，给注册请求对应的promise加一个监听器，当注册请求成功之后回调这个监听器，里面进行网络层面的bind操作
io.netty.util.concurrent.DefaultPromise.addListener    1    133    //略
io.netty.util.concurrent.DefaultPromise.isDone    1    106    //检查promise对应的请求是不是已经处理完。添加监听器的过程中要检查这个，因为异步请求可能在添加监听器的过程中就已经完成，可以直接执行回调，如果这个时候还加回调，这个回调时永远没机会触发的
io.netty.channel.DefaultChannelPromise.executor    1    56    //略
io.netty.util.concurrent.DefaultPromise.executor    1    87    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    1    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    1    428    //略
io.netty.util.concurrent.SingleThreadEventExecutor.execute    1    682    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    1    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    1    428    //略
io.netty.util.concurrent.SingleThreadEventExecutor.addTask    1    296    //略。当前还处于addListener的过程中，监听器由请求的发起方添加，由异步请求执行方调用，但是上面说过，如果isDone了，就应该直接执行回调，由于请求方不能执行，所以把监听器要做的事情又整理成一个异步请求，这个就是所谓的notifyLateListener
io.netty.util.concurrent.SingleThreadEventExecutor.isShutdown    1    602    //略
io.netty.util.internal.MpscLinkedQueue.add    1    218    //略
io.netty.util.internal.MpscLinkedQueue.offer    1    114    //略
io.netty.util.internal.MpscLinkedQueueTailRef.getAndSetTailRef    1    52    //略
io.netty.util.internal.UnsafeAtomicReferenceFieldUpdater.get    1    60    //略
io.netty.util.internal.UnsafeAtomicReferenceFieldUpdater.compareAndSet    1    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.isShutdown    1    602    //略
io.netty.channel.SingleThreadEventLoop.wakesUpForTask    1    66    //判断要不要唤醒处理刚才加的task的eventloop（。NonWakeupRunnable类型的task添加到taskqueue之后是不需要唤醒的。
io.netty.channel.nio.NioEventLoop.wakeup    1    590        //略
io.netty.util.internal.MpscLinkedQueueHeadRef.lazySetHeadRef    18    52    //略。运行到这里，新起的eventloop开始工作了，从taskqueue中poll任务了，队列操作相关的都不介绍
io.netty.channel.DefaultChannelPromise.executor    18    56    //略
io.netty.util.concurrent.DefaultPromise.executor    18    87    //略
io.netty.util.concurrent.DefaultPromise.cause    18    124    //略。执行到这里，上面提到的notifyLateListener任务已经从task queue中取出来执行了，执行前要判断一下是不是真的成功了。
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.SingleThreadEventExecutor.execute    18    682    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.util.concurrent.SingleThreadEventExecutor.addTask    18    296    //略。这里处于notifyLateListener的执行过程中，当前场景中这个notifyLateListener最重要的工作就是发起一个异步的网络层面的bind请求。
io.netty.util.concurrent.SingleThreadEventExecutor.isShutdown    18    602        //略
io.netty.util.internal.MpscLinkedQueue.add    18    218    //略
io.netty.util.internal.MpscLinkedQueue.offer    18    114    //略
io.netty.util.internal.MpscLinkedQueueTailRef.getAndSetTailRef    18    52    //略
io.netty.util.internal.UnsafeAtomicReferenceFieldUpdater.get    18    60    //略
io.netty.util.internal.UnsafeAtomicReferenceFieldUpdater.compareAndSet    18    39    //略
io.netty.channel.SingleThreadEventLoop.wakesUpForTask    18    66    //略
io.netty.channel.nio.NioEventLoop.wakeup    18    590    //略
io.netty.util.internal.MpscLinkedQueueHeadRef.lazySetHeadRef    18    52    //略
io.netty.util.concurrent.DefaultPromise.isSuccess    18    115    //判断异步请求是不是成功处理。到这里，上面提到的异步bind请求任务已经在执行了，执行之前要先判断一下之前的异步请求（通道注册）是不是已经完成
io.netty.channel.AbstractChannel.bind    18    198    //略
io.netty.channel.DefaultChannelPipeline.bind    18    903    //略
io.netty.channel.AbstractChannelHandlerContext.bind    18    414    //略。异步请求总是从channel传到pipeline，再到handler对应的context，如果是IO操作就会进一步传到socket
io.netty.util.concurrent.DefaultPromise.isDone    18    106    //略。在context真正调用底层的nio处理bind前，先检查一下到这个promise是不是被取消了
io.netty.channel.DefaultChannelPromise.channel    18    66    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.util.concurrent.DefaultPromise.setUncancellable    18    456    //略。马上就要真的bind了，就不允许取消了，否则bind实际完成了但是地方认为bind已经被取消
io.netty.channel.nio.AbstractNioChannel.isOpen    18    103    //判断通道是否打开。bind之前要确保通道打开，否则通道处理不了连接，bind了也没用
io.netty.channel.socket.nio.NioServerSocketChannel.config    18    100    //获取通道socket相关的配置
io.netty.channel.socket.DefaultServerSocketChannelConfig.getOption    18    60        //略
io.netty.channel.DefaultChannelConfig.getOption    18    124    //略
io.netty.channel.socket.nio.NioServerSocketChannel.isActive    18    105    //判断通道是否激活。bind的过程中这个判断主要用来决定是不是在pipeline中传播“已激活”事件
io.netty.channel.socket.nio.NioServerSocketChannel.javaChannel    18    115        //略
io.netty.channel.nio.AbstractNioChannel.javaChannel    18    112    //略
io.netty.channel.socket.nio.NioServerSocketChannel.doBind    18    125    //略
io.netty.channel.socket.nio.NioServerSocketChannel.javaChannel    18    115    //略
io.netty.channel.nio.AbstractNioChannel.javaChannel    18    112    //略
io.netty.channel.socket.DefaultServerSocketChannelConfig.getBacklog    18    136    //获取TCP连接的挤压配置。
io.netty.channel.socket.nio.NioServerSocketChannel.isActive    18    105    //略
io.netty.channel.socket.nio.NioServerSocketChannel.javaChannel    18    115    //略
io.netty.channel.nio.AbstractNioChannel.javaChannel    18    112    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.SingleThreadEventExecutor.execute    18    682    //略。如果bind操作过后通道激活，则传播“已激活“事件虽然当前处于channel绑定的eventloop线程中，但是”已激活“事件还是以异步请求的方式处理，可能是因为目前是在poll task处理任务的过程中，做完了就让位给其他task，可以晚点做点做的就later一点再做）
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428//略
io.netty.util.concurrent.SingleThreadEventExecutor.addTask    18    296//略
io.netty.util.concurrent.SingleThreadEventExecutor.isShutdown    18    602//略
io.netty.util.internal.MpscLinkedQueue.add    18    218//略
io.netty.util.internal.MpscLinkedQueue.offer    18    114//略
io.netty.util.internal.MpscLinkedQueueTailRef.getAndSetTailRef    18    52//略
io.netty.util.internal.UnsafeAtomicReferenceFieldUpdater.get    18    60//略
io.netty.util.internal.UnsafeAtomicReferenceFieldUpdater.compareAndSet    18    39//略
io.netty.channel.SingleThreadEventLoop.wakesUpForTask    18    66//略
io.netty.channel.nio.NioEventLoop.wakeup    18    590    //略
io.netty.channel.DefaultChannelPromise.trySuccess    18    82    //把事件处理结果设置为成功。执行到这里bind操作已经成功了，bind请求对应的promise可以设置为成功了
io.netty.util.concurrent.DefaultPromise.trySuccess    18    405    //略
io.netty.util.concurrent.DefaultPromise.isDone    18    106    //略
io.netty.util.concurrent.DefaultPromise.isDone    18    106    //略
io.netty.channel.DefaultChannelPromise.addListener    18    93    //略。为bind操作添加监听器。
io.netty.util.concurrent.DefaultPromise.addListener    18    133    //略
io.netty.util.concurrent.DefaultPromise.isDone    18    106    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.util.concurrent.FastThreadLocalThread.threadLocalMap    18    62    //略。目前还在添加事件完成监听器的过程中，但是上面已经说过，事件可能在添加监听器之前就已经完成了，所以添加监听器的过程会变成直接调用本来应该是回调的操作。
io.netty.util.internal.InternalThreadLocalMap.futureListenerStackDepth    18    202    //可以在异步请求完成的回调中发起新的异步请求，但是这种操作会被futureListenerStackDepth限制，如果在回调的时候发现这个值超过限制，就不可以执行回调，因为没办法保证回调里面是不是又发起了异步请求
io.netty.util.internal.InternalThreadLocalMap.setFutureListenerStackDepth    18    206    //略
io.netty.util.concurrent.DefaultPromise.isSuccess    18    115    //判断异步请求是否成功。
io.netty.util.internal.InternalThreadLocalMap.setFutureListenerStackDepth    18    206    //略
io.netty.util.internal.MpscLinkedQueueHeadRef.lazySetHeadRef    18    52    //略。开始获取另外一个任务了
io.netty.util.internal.MpscLinkedQueueNode.clearMaybe    18    56    //略
io.netty.util.internal.OneTimeTask.value    18    30    //略
io.netty.channel.DefaultChannelPipeline.fireChannelActive    18    817    //略。上面说过”已激活“事件是以异步请求的方式处理的，现在处理的就是这个请求任务。
io.netty.channel.AbstractChannelHandlerContext.fireChannelActive    18    176    //略
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.DefaultChannelHandlerContext.handler    18    35    //略
io.netty.channel.ChannelInboundHandlerAdapter.channelActive    18    64    //略
io.netty.channel.AbstractChannelHandlerContext.fireChannelActive    18    176    //略
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.socket.nio.NioServerSocketChannel.config    18    100    //略
io.netty.channel.DefaultChannelConfig.isAutoRead    18    274    //略
io.netty.channel.AbstractChannel.read    18    228    //略。pipeline在传播”已激活“事件之后，如果发现通道配置了自动读取，就会直接开始从通道中读数据了。
io.netty.channel.DefaultChannelPipeline.read    18    933    //略
io.netty.channel.AbstractChannelHandlerContext.read    18    592    //略
io.netty.channel.AbstractChannelHandlerContext.executor    18    112    //略
io.netty.channel.AbstractChannelHandlerContext.channel    18    97    //略
io.netty.channel.nio.AbstractNioChannel.eventLoop    18    117    //略
io.netty.channel.AbstractChannel.eventLoop    18    109    //略
io.netty.util.concurrent.AbstractEventExecutor.inEventLoop    18    39    //略
io.netty.util.concurrent.SingleThreadEventExecutor.inEventLoop    18    428    //略
io.netty.channel.socket.nio.NioServerSocketChannel.isActive    18    105    //略
io.netty.channel.socket.nio.NioServerSocketChannel.javaChannel    18    115    //略
io.netty.channel.nio.AbstractNioChannel.javaChannel    18    112    //略
io.netty.channel.nio.AbstractNioChannel.doBeginRead    18    361    //略
